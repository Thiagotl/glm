---
title: "Explorando a Relação entre Variáveis Ambientais e a Produção de Clorofila-a em Cianobactérias: Uma Abordagem com Modelos Lineares Generalizados"
author: "Thiago Tavares Lopes"
date: "`r format(Sys.time(), '%d %B %Y')`"
header-includes:
   - \usepackage[brazil]{babel}
   - \usepackage{bm}
   - \usepackage{float}
   - \usepackage{multirow}
geometry: left=2.5cm, right=2.5cm, top=2cm, bottom=2cm
output:
  bookdown::pdf_document2:
    fig.align: 'center'
editor_options:
  chunk_output_type: console
  markdown: 
    wrap: sentence
---
```{r setup, include=FALSE}
options(encoding = "UTF-8")
options(OutDec = ",")
options(scipen = 999, digits =5)

```

```{r, include=FALSE}

library(readxl)
library(tidyverse)
library(MASS)
library(fmsb)
library(modEvA)
library(kableExtra)
library(knitr)
library(GGally)
library(hnp)



```


# Introdução 

Foi proposto um modelo linear generalizado para avaliar a produção de clorofila a em  cianobactérias em diferentes condições climáticas. O *dataset* utilizado foi obtido do catálogo de dados público do governo dos Estados Unidos, disponível em [*Data.Gov*](https://catalog.data.gov/dataset/river-cyanobacteria-datasets). Esse *datset* possui informações detalhadas sobre diferentes espécies de cianobactérias, sendo elas: Informações genéticas, condições climáticas do local de coleta das amostras e localização geográfica da coleta. Para a construção do modelo, foram consideradas exclusivamente as informações de clorofila a quantificada e condições ambientais (físicas e químicas) do local da coleta das amostras. O trabalho aqui desenvolvido foi fundamentado no artigo disponível no seguinte [link](https://www.nature.com/articles/s41598-023-29037-6).




```{r, include=FALSE}
ciano <- read_excel("G:/Meu Drive/estatistica/mlg/glm/trab_final/ciano.xlsx")
ciano$chlorophyll_a<-as.double(ciano$chlorophyll_a)
ciano$chlorophyll_a[is.na(ciano$chlorophyll_a)]<-round(mean(ciano$chlorophyll_a, na.rm = TRUE), 2)

#Descritiva basica para o dataset

summary(ciano)

# primeiro modelo 

fit <- glm(chlorophyll_a ~ ., family = Gamma(link = "log"), data = ciano)

#fit do primeiro modelo
summary(fit)


#verificando o ajuste do modelo usando o deviance

qchisq(0.95,44)
```




```{r, include=FALSE}
#tabela com os valores do primeiro fit 

summary_fit<-summary(fit)

coef_table<-summary_fit$coefficients

coef_df<-as.data.frame(coef_table)


coef_df$Significance <- cut(coef_df[, 4], 
                            breaks = c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf), 
                            labels = c("***", "**", "*", ".", ""))


```


Modelo 1


```{r echo=FALSE, label=""}

kbl(coef_df, caption = "", booktabs = TRUE) |> 
  kable_styling(latex_options = c("striped","HOLD_position")) |> 
  add_footnote(c("Nota:*** p<0.001; ** p<0.01; * p<0.05; . p<0.1"))

```


Foi construído um novo modelo a partir do resultado da técnica de *stepwise*. 



```{r, include=FALSE}
fit2<-glm(formula = chlorophyll_a ~ total_nitrogen + total_phosphorus + 
            dissolved_oxigen + pH_water + carbon_dioxide_water, family = Gamma(link = "log"), 
          data = ciano)
summary(fit2)

qchisq(0.95,52)

```

# Resultados 
Nesta seção são apresentados os resultados da análise de resíduos para o modelo 2


## Análise de Resíduos



```{r}
# RESIDUAL ANALYSIS


# coeficiente de determinacao generalizado (Nagelkerke, 1991)

RsqGLM(fit2,plot=F)



# DIAGNOSTIC ANALYSIS 


td = resid(fit2,type="deviance")

# RESIDUOS X INDICES

abline(plot(td), lty=c(2,2,3), h=c(-2,2,0))


abline(plot(fitted(fit2),td) , lty=c(2,2,3), h=c(-2,2,0))




#fitted(fit2) -  aqui os valores já estão na escala original da variável resposta 

#valores estimados para o preditor linear 

#fit2$linear.predictors


```



```{r}
n1=2


#envelope simulado

hnp(fit2, halfnormal = F, how.many.out = T)


# Alavancagem
# alavancagem vs valores ajustados
plot(fitted(fit2),hatvalues(fit2),ylab="Alavancagem")
#identify(fitted(fit),hatvalues(fit), n=n1) # identifica n1 valores no grafico
#which(hatvalues(fit2)>0.3)

# DFFIT
plot(dffits(fit2),ylab="DFFITS")
#identify(dffits(fit1), n=n1) # identifica n1 valores no grafico

# distancia de Cook
# cook vs valores ajustados
plot(fitted(fit2),cooks.distance(fit2),ylab="Distancia de Cook")
#identify(fitted(fit1),cooks.distance(fit1), n=n1) 
#which(cooks.distance(fit2)>0.2)


```


















































